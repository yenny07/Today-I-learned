## 10844 : 쉬운 계단 수
### 문제
https://www.acmicpc.net/problem/10844
### 코멘트
도대체 뭐가 '쉬운' 계단 수인 건지,,,?

포인트는 '각 자리의 수에서 맨 뒤에 올 수 있는 숫자들의 경우의 수'다.

자리 수가 1일 때, 맨 뒤에 올 수 있는 숫자들의 경우는 0부터 9까지 총 10가지다.
자리 수가 2일 때, 맨 뒤에 올 수 있는 숫자들의 경우는
0이 올 수 있는 경우 1개 (10) <br>
1이 올 수 있는 경우 2개 (01, 21) <br>
2가 올 수 있는 경우 2개 (12, 32) <br>
... <br>
8이 올 수 있는 경우 2개 (78, 98) <br>
9가 올 수 있는 경우 1개 ~89) <br>

자리 수가 3이라면? <br>
0이 올 수 있는 경우 1개 (010) <br>
1이 올 수 있는 경우 3개 (101, 121, 321) <br>
2가 올 수 있는 경우 3개 (212, 232, 432) <br>
3이 올 수 있는 경우 4개 (323, 343, 123, 543) <br>
... <br>
8이 올 수 있는 경우 3개 <br>
9가 올 수 있는 경우 2개 <br>

표로 정리해보면 아래와 같다. <br>

(맨 뒷자리) 0 1 2 3 4 5 6 7 8 9 <br>
--------------------------------------- <br>
자리 수 1 : 0 1 1 1 1 1 1 1 1 1 <br>
자리 수 2 : 1 1 2 2 *2* 2 *2* 2 2 1 <br>
자리 수 3 : 1 3 3 4 4 *4* 4 4 3 2 <br>

각 숫자들은 윗줄에서 대각선 자리에 있는 두 수를 합한 값이다. 기울임 표시 2 + 2 = 4.

왜~냐.

자리수 3일 때 맨 뒷자리 5가 나올 수 있는 경우의 수를 보자.
자리 수가 2일 때 4나 6으로 끝난 수에다가'만' 숫자 5을 마지막에 붙여 세 자리를 만들 수 있는 것이다.
(34, 54), (56, 76) -> (345, 545, 565, 765)

위 표를 이차원 배열 dp[][]에 담아 점화식으로 표현하면
i = 자리수(행), j = 맨 뒷자리(열)

j = 0   dp[i][j] = dp[i-1][1]                   # 윗 줄의 오른쪽 대각선 (왼쪽 대각선 값 없음)
j = 2~8 dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]  # 윗 줄의 왼쪽 대각선 + 오른쪽 대각선
j = 9   dp[i][j] = de[i-1][8]                   # 윗 줄의 왼쪽 대각선 (오른쪽 대각선 값 없음)


### 코드
```python
from sys import stdin

n = int(stdin.readline())
dp = [[0 for i in range(10)] for j in range(101)]
for i in range(1, 10):
    dp[1][i] = 1
for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i - 1][1]
        elif j == 9:
            dp[i][j] = dp[i - 1][8]
        else:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
print(sum(dp[n]) % 1000000000)
```
### 결과
29200kb, 72ms
