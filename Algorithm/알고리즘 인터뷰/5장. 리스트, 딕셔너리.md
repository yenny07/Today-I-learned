## 리스트
말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 Mutable List를 말하며, 내부적으로 동적으로 구현되어 있다.
리스트는 다양한 기능을 제공해 큐를 사용할지, 스택을 사용할지 고민하지 않아도 된다.
다양한 기능을 제공하면서도 O(1)에 실행 가능한 연산ㄷ르도 몇 가지 있다. (요소를 삭제하거나 큐의 첫 번째 요소를 추출하는 pop(0)은 O(n)이다.)

| 연산 | 시간 복잡도 | 설명 |
|------|-----------|-----|
|len(a)|O(1)|전체 요소의 개수를 리턴한다.|
|a[i]|O(1)|인덱스 i의 요소를 가져온다.|
|a[i:j]|O(k)|인덱스 i부터 j-1까지의 요소 k개를 가져온다. <br>객체 k개에 대한 조회가 필요하므로 O(k)다.|
|elem in|O(n)|elem 요소가 존재하는지 확인한다. <br>순차 탐색이 필요하므로 O(n)이 소요된다.|
|a.count(elem)|O(n)|elem 요소의 개수를 리턴한다.|
|a.index(elem)|O(1)|elem 요소의 인덱스를 리턴한다.|
|a.append(elem)|O(1)|리스트 마지막에 elem 요소를 추가한다.|
|a.pop()|O(1)|리스트 마지막 요소를 추출한다. (스택의 연산)|
|a.pop(0)|O(n)|리스트 첫번째 요소를 추출한다. <br>전체 복사가 필요하므로 O(n)이다. (큐의 연산)|
|del a[i]|O(n)|i에 따라 다르지만, 최악의 경우 O(n)이다.|
|a.sort()|O(nlogn)|팀소트를 사용해 정렬한다. 최선의 경우 O(n)도 가능하다.|
|min(a), max(a)|O(n)|전체를 선형 탐색해야 한다.|
|a.reverse()|O(n)|뒤집는다.|

### 리스트의 활용 방법
```python
# 선언
arr = list()
another_arr = []

# 값 추가
arr.append('안녕')
arr.insert(3, 5)

# 슬라이싱 응용 : 세번째 파라미터는 단계(Step)로, 2로 준다면 두 칸씩 건너뛰게 된다.
arr[1:4:2]

# 값 삭제
del arr[0]
arr.remove(3)
a = arr.pop()
```

### 리스트의 특징
파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장접과, 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 형태다.
CPython에서 리스트를 정의한 헤더 파일을 뜯어보면, 리스트는 요소에 대한 포인터 목록(ob_item)을 갖고 있는 구조체로 선언되어 있다.
이 ob_item이 곧 객체들의 포인터 목록을 참초한다. 객체들의 포인터들은 각각 객체 값을 참조한다.
사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하며, 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친듯 강력하다.

리스트에 여러 자료형을 담을 수 있지만, 각 자료형의 크기는 저마다 다르기 때문에 이들을 연속된 메모리 공간에 할당할 수는 없다.
결국 각각의 객체에 대한 참조로 구현해야 한다. 당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입코드를 확인하고 값을 일일이 살펴봐야 하는 등,
추가적인 작업이 필요하기 때문에 속도 면에서 훨씬 불리하다.

파이썬은 강력한 기능을 위해 참조를 택했고, 이로 인해 부득이하게 속도를 희생한 면이 있다.


## 딕셔너리
자바의 HashMap과 비슷하다.
인덱스를 숫자로만 지정할 수 있는 리스트와 달리, 딕셔너리는 문자를 포함해 다양한 타입을 키로 사용할 수 잇다.
특히 파이썬의 딕셔너리는 해시할 수만 있다면 문자, 집합까지 불변 객체는 모두 키로 사용할 수 있다.
해시 테이블의 강점은 다양한 타입의 키뿐 아니라, 입력과 조회 모두 O(1)에 가능하다. 최악의 경우 O(n)이겠으나, 대부분의 경우 훨씬 빠르다.

|연산|시간복잡도|설명|
|---|---------|------------|
|len(a)|O(1)|요소의 개수를 리턴한다.|
|a[key]|O(1)|키를 조회하여 값을 리턴한다.|
|a[key] = value|O(1)|키/값을 삽입한다.|
|key in a|O(1)|딕셔너리에 키가 존재하는지 확인한다.|

파이썬에서 딕셔너리는 원래 입력 순서가 유지되지 않았다. 3.7부터 지원되는데, 3.6 이하를 사용하는 곳이 여전히 많고 하위 버전과의 호환성, 코테 시 인터프리터의 버전을
정확히 알 수 없는 상황에서는 입력 순서가 유지되지 않을 수 있다. 이 땐 collections.OrderedDict()을 사용하자.
조회 시 항상 디폴트 값을 생성해 키 오류를 방지하는 collections.defaultdict(),
요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 collections.Counter() 등이 있다. 내사랑 카운터!

### 딕셔너리의 활용 방법
```python
# 선언 및 할당
a = dict()
a = {}
a = {'key1':'value1', 'key2':'value2'}
a['key3'] = 'value3'

# 삭제 및 조회
del a['key1']
for k, v in a.items():
    print(k, v)
```

### 딕셔너리 모듈
defaultdict, counter, OrderedDict에 대해 각각 살펴보자.

1. defaultdict
defaultdict 객체는 존재하지 않는 키를 조회할 경우, 에러 메세지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
```python
a = collections.defaultdict(int)
a['A'] = 5
a['B'] = 4
print(a)    # defaultdict(<class 'int'>, {'A':5, 'B': 4})


a['C'] += 1     # ???
```
C는 존재하지 않는 키다. 원래의 딕셔너리라면 KeyError가 발생하겠지만, defaultdict 객체는 에러 없이 바로 +1 연산이 가능하고,
이 경우 디폴트인 0을 기준으로 자동 생성한 후 여기에 1을 더해 최종적으로 1이 만들어진다.
죄종적으로 a를 출력해보면, defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C': 1})


2. Counter 객체
카운터는 아이템에 대한 개수를 계산해 딕셔너리로 리턴한다.
```python
a = [1, 2, 5, 5, 5, 6, 6]
b = collections.Counter(a)
print(b)    # Counter({5: 3, 6: 2, 1: 1, 2: 1})
```

키에는 아이템의 값이, 값에는 개수가 들어간다. 빈도가 가장 높은 것부터 내림차순으로 정렬되어 리턴된다.

그렇다면 Counter에서 가장 빈도 수가 높은 요소는 어떻게 추출할 수 있을까?
most_common()을 사용하면 된다.

```python
print(b.most_common(2))     #[(5, 3), (6, 2)]
```


3. OrderedDict
대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬도 3.6 이하에서는 마찬가지였다.
```python
collections.OrderedDict({'banana':3, 'apple':4, 'pear':1, 'orange':2})
>> OrderedDict([('banana', 3), ('apple', 4), ('pear', 1), ('orange', 2)])
```

3.7부터는 기본 딕셔너리만 사용해도 입력 순서가 충분히 유지된다.
그러나 코딩 테스트 시 인터프리터가 하위 버전일 수 있다. 충분히 응...
해시 테이블은 원래 입력 순서에 관여하지 않는 자료형인 만큼, 순서를 기대하지 말자.
