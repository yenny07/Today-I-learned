6장부터는 문제를 본격적으로 풀이해보면서, 파이썬의 문자열 자료형에는 어떤 기능들이 제공되고 어떤 기법들이 쓰이는지 하나씩 살펴본다.

## 01. 유효한 팰린드롬
주어진 문자열이 팰린드롬인지 확인하라.
대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

팰린드롬은 뒤집어도 같은 말이 되는 단어나 문장이다.
한글로는 '소주 만 병만 주소'같은 문장이다.

방법 1. 리스트로 변환
```python
def isPalindrome(self, s: str) -> bool:
    strs = []
    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if strs.pop(0) != strs.pop():
            return False

    return True
```

방법 2. 데크 자료형으로 최적화
성능적으로 훨씬 낫다.
```python
def isPalindrome(self, s:str) -> bool:
    strs: Deque = collections.deque()
    
    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if strs.popleft() != strs.pop():
            return False

    return True
```

구조상 흐름은 방법 1과 같다. 단지 strs를 리스트가 아닌 Deque로 선언했다.
이것만으로도 304밀리초에서 64밀리초로 시간을 확 단축할 수 있다. 이게 너무 신기하다. 거의 5배나 빨라졌다.
이는 리스트의 pop(0)이 O(n)인 데 반해, 데크의 popleft()는 O(1)이기 때문이며, 
이 작업을 각각 n번씩 반복하면 리스트는 O(n^2), 데크는 O(n)이기 때문이다. 데크 만세.

방법 3. 슬라이싱
```python
def isPalindrome(self, s:str) -> bool:
    s = s.lower()
    s = re.sub('[^a-z0-9]', '', s)  # 정규식으로 불필요한 문자는 필터링
    
    return s == s[::-1]
```

별다른 알고리즘은 없고 강력한 정규식 기능이 있는^^ 풀이다.
앞서 풀이에서는 isalnum()으로 모든 문자를 일일이 점검했지만, 여기선 문자열 전체를 한 번에 영숫자만 걸러내도록 정규식으로 처리했다.
마지막엔 [::-1]을 이용해 뒤집어 비교 후 불린 값을 리턴하도록 했다.
이 경우 실행속도는 무려,,,, 36밀리초,,
isalnum()을 계속 호출하지 않아서 그런 듯 하다. 생각도 못한 방법인데 재밌다.

오늘 가게일이 너무 바빴어서 거진 10시간이나 근무하는 바람에 알고리즘 공부를 많이 못 했다.
내일은 문자열 싹 끝내버려야지!!!


