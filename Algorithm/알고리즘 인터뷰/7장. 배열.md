자료구조 : 1) 메모리 공간 기반의 '연속' 방식, 2) 포인터 기반의 '연결' 방식
배열은 이 중에서도 1)의 연속 방식의 기본 자료형이다. 고정된 크기만큼의 연속된 메모리 할당이다.

int를 4바이트로 가정하고, 메모리에 대한 접근은 바이트 단위로 한다.
int형 배열을 선언하면 각 엘리먼트는 4바이트고, 배열의 주소 또한 4씩 증가한다.

무엇보다 배열은 어느 위치에나 O(1)에 조회가 가능하다는 장점이 있다.
즉시 주소를 계산할 수 있고, 언제든 해당 메모리 주소에 있는 값을 O(1)에 조회한다.

실제 데이터에서는 전체 크기를 가능하기 힘들 때가 많다.
할당된 영역이 너무 좁거나 넓을 수 있다. 그래서 동적 배열이 등장했다.

원리는 간단하다. 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사한다.
더블링(Doubling)이라 하여 대게 2배씩 늘려주는데, 언어마다 늘려가는 비율은 상이하다.
파이썬은 0, 4, 8, 16, 25, 35, 46 ... 크기로 늘려준다.
이 재할당 비율을 Growth Factor, 즉 '성장 인자'랃고 한다. 전체적으로 1.125배로 다른 언어에 비해서는 다소 조금만 늘려간다. 

동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하며, 조회 또한 동일하게 O(1)이다.
그러나 더블링이 필요한 만큼 공간이 차게 되면 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n)의 비용이 발생한다.
자주 일어나는 일은 아니며, 분할 상환 분석에 따른 입력 시간은 여전히 O(1)이다. 구우웃.

## 07. 두 수의 합
> 리트코드 1. Two Sum

덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.

### 방법 01. 브루트 포스
제일 먼저 생각난 방법이다 ㅋㅋㅋ
배열을 두 번 반복하면서 일일이 확인해보는 무차별 대입 방식이다. 
```python
def twoSum(self, nums, target: int) -> List[int]:
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
```

### 방법 02. in을 이용해 탐색
target - n이 배열 안에 존재하는지 확인하는 것이 포인트다. 와..
```python
def twoSum(self, nums, target: int) -> List[int]:
    for i, n in enumerate(nums) # 리스트에 인덱스를 달아 (idx, n)으로 돌려주는 enumerate
        num = target - n
        
        if num in nums:
            return [nums.index(n), nums[i+1:].index(num) + (i+1)]   # 중복된 수를 피하기 위한 발악
```


