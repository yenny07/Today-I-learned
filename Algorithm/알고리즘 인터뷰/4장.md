4장. 빅오, 자료형

## 빅오
: 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법(파일 크기에 따른 소요 시간)<br>


O(1): 입력값이 아무리 커도 실행시간은 일정하다. 최고의 알고리즘이다. 누군가 상수 시간을 갖는 알고리즘을 홍보한다면 일단 의심해봐야 한다. 또한 상수값이 매우 매우 크다면 사실상 의미가 없다.
해시 테이블의 조회 및 삽입(11장)이 이에 해당한다.<br>

O(logN): 웬만한 n의 크기에 대해서 매우 견고하다. 이진 검색이 이에 해당한다. <br>

O(n): 입력값에 걸리는 시간이 비례한다. 선형 시간 알고리즘이다. 모든 입력값을 적어도 한 번 이상은 봐야하는 경우다.<br>

O(nlogn): 머지 소팅 및 효율 좋은 정렬 알고리즘이 이에 해당한다. 비교기반 알고리즘은 아~무리 좋아도 이 이상 나올 수가 없다. 입력값이 최선인 경우 빼곤ㅎ <br>

O(n^2): 버블 소팅이 이에 포함한다. (버블 소팅 재밌었는데...)<br>

O(2^n): 피보나치를 재귀로 계산하는 알고리즘이 이에 해당한다. n^2보다 훨~씬 더 크다.<br>

O(n!): 외판원 문제가 이에 해당한다. 날 괴롭혔던 브루트 포스가 거진 여기에 해당하며, 가장 느리다.<br><br>

자료구조 시간에 유교수님이 현실 서비스에선 n^2도 약간 힘들며, 2^n은 아예 쓸 수 없다고 지나가며 하신 말씀이 생각난다. 교수님 저 아직도 알고리즘 해요 ,,,,

## 상한과 최악
빅오(O)는 상한을 의미한다. 이 외에도 하한을 나타내는 빅오메가와, 평균을 나타내는 빅세타가 있다. 업계에서는 빅오와 빅세타를 합쳐서 표현하려는 경향이 있다.
상한과 최악의 경우를 혼동하면 안된다. 빅오는 '적당히 정확하게' 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없다.
즉 가장 빨리 실행될 때(하한)와 가장 빨리 실행될 때(상한)를 그래프로 표현했을 때, 이 중 가장 늦게 실행될 때를 간략화하여 빅오, 가장 빨리 실행될 때를 빅오메가, 평균일 때를 빅 세타로 지칭한다.
빅오 표기법은 n이 매우 클 때의 전체적인 큰 그림에 집중한다. 어떤 정렬이 '최선의 경우 O(nlogn)이다.'가 참일 때, '최선의 경우 O(n^2)이다.'는 명제도 참이다. 빅오는 상한을 의미하므로 실제 연산 횟수가 이보다 작기만 하면 되기 때문이다.
상한을 지나치게 높게 설정했기 때문에 당연히 의미는 없다.

*빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.*
```python
```


