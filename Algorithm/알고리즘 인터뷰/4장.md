4장. 빅오, 자료형

## 빅오
: 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법(파일 크기에 따른 소요 시간)<br>


O(1): 입력값이 아무리 커도 실행시간은 일정하다. 최고의 알고리즘이다. 누군가 상수 시간을 갖는 알고리즘을 홍보한다면 일단 의심해봐야 한다. 또한 상수값이 매우 매우 크다면 사실상 의미가 없다.
해시 테이블의 조회 및 삽입(11장)이 이에 해당한다.<br>

O(logN): 웬만한 n의 크기에 대해서 매우 견고하다. 이진 검색이 이에 해당한다. <br>

O(n): 입력값에 걸리는 시간이 비례한다. 선형 시간 알고리즘이다. 모든 입력값을 적어도 한 번 이상은 봐야하는 경우다.<br>

O(nlogn): 머지 소팅 및 효율 좋은 정렬 알고리즘이 이에 해당한다. 비교기반 알고리즘은 아~무리 좋아도 이 이상 나올 수가 없다. 입력값이 최선인 경우 빼곤ㅎ <br>

O(n^2): 버블 소팅이 이에 포함한다. (버블 소팅 재밌었는데...)<br>

O(2^n): 피보나치를 재귀로 계산하는 알고리즘이 이에 해당한다. n^2보다 훨~씬 더 크다.<br>

O(n!): 외판원 문제가 이에 해당한다. 날 괴롭혔던 브루트 포스가 거진 여기에 해당하며, 가장 느리다.<br><br>

자료구조 시간에 유교수님이 현실 서비스에선 n^2도 약간 힘들며, 2^n은 아예 쓸 수 없다고 지나가며 하신 말씀이 생각난다. 교수님 저 아직도 알고리즘 해요 ,,,,

### 상한과 최악
빅오(O)는 상한을 의미한다. 이 외에도 하한을 나타내는 빅오메가와, 평균을 나타내는 빅세타가 있다. 업계에서는 빅오와 빅세타를 합쳐서 표현하려는 경향이 있다.
상한과 최악의 경우를 혼동하면 안된다. 빅오는 '적당히 정확하게' 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없다.
즉 가장 빨리 실행될 때(하한)와 가장 빨리 실행될 때(상한)를 그래프로 표현했을 때, 이 중 가장 늦게 실행될 때를 간략화하여 빅오, 가장 빨리 실행될 때를 빅오메가, 평균일 때를 빅 세타로 지칭한다.
빅오 표기법은 n이 매우 클 때의 전체적인 큰 그림에 집중한다. 어떤 정렬이 '최선의 경우 O(nlogn)이다.'가 참일 때, '최선의 경우 O(n^2)이다.'는 명제도 참이다. 빅오는 상한을 의미하므로 실제 연산 횟수가 이보다 작기만 하면 되기 때문이다.
상한을 지나치게 높게 설정했기 때문에 당연히 의미는 없다.

*빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.*

### 분할 상환 분석
빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법이다. 
예로 '동적 배열'을 들 수 있는데, 더블링이 일어날 수 있지만 이로 인해 '삽입 시 시간 복잡도는 O(n)이다.'라고 얘기하는 것이 지나치게 비관적이고 정확하지도 않다.
따라서 이 경우 최악의 경우를 여러번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다. 이러면 동적 배열의 삽입 시 시간 복잡도는 O(1)이 된다.


### 병렬화
병렬 연산이 가능한 알고리즘이 최근에 큰 주목을 받고 있다.
CPU가 비행기로 짐을 여러 번 나르는 것이라면 GPU의 병렬 연산은 배로 수많은 짐을 한 번에 나르는 것에 비유할 수 있다.


## 자료형
### 파이썬 자료형
1. 숫자
숫자 정수형으로 int만 제공한다. bool은 엄밀히 따지면 논리 자료형이지만 파이썬에서는 내부적으로 1(True), 0(False)로 처리되는 int의 서브 클래스다.
int는 object의 하위 클래스이기도 하다. 결국 object > int > bool의 구조다.

2. 매핑
매핑 타입은 키와 자료형으로 구성된 복합 자료형이며, 딕셔너리가 이에 포함된다.

3. 집합
파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는다. 빈 집합은 set()으로 생성하고, 값이 있는 집합은 hey = {1, 2}와 같이 선언한다.
당연하게도, 입력 순서는 유지되지 않는다.

4. 시퀀스
우리말로 '수열'이다. str은 문자의 순서가 있는 나열로 문자열을 이루는 자료형이며, list는 다양한 값들을 배열 형태의 순서있는 나열이다.
불변과 가변으로 구분하는데, 불변에는 str, tuple, bytes가 해당되고 이 타입으로 한번 선언된 값은 변경할 수가 없다.
str은 변경될 수 있는데? 싶지만, str 타입에 다른 문자열을 할당하는 순간 다른 메모리에 다른 문자열이 새로 잡히고 그 변수는 새 문자열을 참조한다.
기존의 문자열은 메모리 어딘가에 남아있다. 정말로 변경하려면, string[1] = 'd'와 같은 형태로 할당자가 처리되어야하는데, 이 코드는 곧바로 TypeError: 'str' object does not support item assignment 에러가 난다.

반면, list는 가변이다. 자유롭게 값을 추가하고 삭제할 수 있는 동적 배열이다. 

### 원시 타입
원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고, 그 공간을 오로지 값으로만 채워넣는다. 배열이라면, 물리 메모리에 자료형의 크기만큼 공간이 연속된 순서로 배치된다.
C나 자바는 성능에 대한 우선순위가 높은 언어다. 때문에 좀 더 하드웨어에 가까운 원시 타입을 별도로 제공하며, 이로 구현했을 떄 훨씬 더 빠르다.
파이썬은 원시 타입을 지원하지 않는다. 파이썬은 원시 타입의 속도를 포기하는 대신, 객체의 다양한 기능과 편의성을 택했다.
C - 원시 타입
자바 - 원시 타입, 객체(Wrapper Classes)
파이썬 - 객체

### 객체
파이썬은 모든 것이 객체다. 불변 객체와 가변 객체로 구분할 수 있다.
불변 객체 - bool, int, float, tuple, str
가변 객체 - list, set, dict

### 불변 객체
파이썬은 모든 것이 객체다. ~~와 이걸 몰랐네 정말 개념없이 공부했구만~~
다만, 문자와 숫자는 불변 객체라는 차이만 있을 뿐이다.
```python
a = 10
b = a
print(id(10), id(a), id(b))
```
위에서 출력되는 세 메모리 주소 값은 모두 동일하다. a, b는 값을 참조하는 객체니까!
만약 10이 11이 된다면, a와 b의 값이 모두 11로 바뀌게 될까? 아니다. 숫자도 불변이니까.
새롭게 할당된 11의 값을 참조하게 될 것이다.


