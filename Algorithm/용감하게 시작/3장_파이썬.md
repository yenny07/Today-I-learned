책 정독 중에, 요약할 부분인 것 같아 중요한 예제 문장만 남긴다.

### 1. 인덴트
PEP8 기준에 맞춰 공백 4칸이 원칙이다.

### 2. 네이밍 컨벤션
파이썬의 네이밍 컨벤션은 스네이크 케이스를 따른다.
(클래스 네이밍은 파스칼을 쓰는 듯 하다.)

### 3. 타입 힌트
파이썬은 동적 타이핑 언어임에도, 타입 힌트가 문서에 추가되어있다. 
타입 표기 없이 빠르게 사용할 수 있는 장점이 있지만 함수의 파라미터에 어떤 타입을 넘겨야하는지, 리턴값이 무엇인지도 알 수 없다.
프로젝트 규모가 커지면 가독성을 떨어뜨리게 되며 버그를 유발한다.
```python
a: str = "1"
b: int = 1

# 파라미터 a는 정수형, 리턴 값으로 True 또는 False를 리턴할 것
def func(a: int) -> bool:
    ...

```
강제 규약이 아니다보니 여전히 동적으로 할당될 수 있으므로 주의가 필요하다.

### 4. 리스트 컴프리헨션
`map`, `filter`와 같은 함수형 기능을 지원하며 람다 표현식도 지원한다.
```python
# input으로 주는 [1,2,3]에 대해 각각을 x로 잡고 x+10으로 이뤄진 리스트를 만든다.
list(map(lambda x: x+10, [1,2,3]))                  # [11, 12, 13]

# 홀수인 경우 2를 곱해 리스트를 만든다.
[n * 2 for n in range(1, 10 + 1) if n % 2 == 1]     # [2, 6, 10, 14, 18]

# 딕셔너리 컴프리헨션
a = {key:value for key, value in original.items()}
```

### 5. 제너레이터
루프의 반복 동작을 제어할 수 있는 루틴 형태다.
`yield` 구문을 사용하면 제너레이터를 리턴할 수 있다. `return`을 만나면 값을 리턴하고 함수의 동작을 종료하는 것과 달리, `yield`는 제너레이터가 지금까지 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.
만약 다음 값을 생성하려면 `next()`로 추출하면 된다.
```python
def get_natural_number():
    n = 0
    while True:
        n += 1
        yield n

g = get_natural_number()
for _ in range(100):
    print(next(g))  # 다음 값 추출
```

### 6. range
제너레이터의 방식을 활용하는 대표적인 함수다.
만약 생성할 숫자가 100만 개쯤 된다면, 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다.
그러나 제너레이터를 리턴하듯 `range` 클래스만 리턴하면? 생성 조건만 정해두고 필요할 때가 되어서야 생성해 꺼내면 된다.
```python
a = [n for n in range(100000)]      # 이미 생성된 값이 담겨 있고
b = range(100000)                   # 생성해야 한다는 조건뿐!

print(len(a))   # 100000
print(len(b))   # 100000

print(b)           # range(0, 100000)
print(type(b))     # <class 'range'>

print(sys.getsizeof(a))     # 8697464
print(sys.getsizeof(b))     # 48 wow
```

`b`의 메모리 점유율이 훨씬 작다. 생성 조건만 보관하고 있기 때문이다.
생성되지 않았지만, 인덱스로 접근 시 바로 생성되기 때문에 리스트와 거의 동일한 느낌으로 사용할 수 있다.


### 7. enumerate
`enumerate()`는 '열거하다'는 뜻의 함수로, 여러가지 자료형에 인덱스를 자동으로 부여하여 `enumerate` 객체로 리턴한다.
```python
lst = [9, 7, 0, 7]
list(enumerate(lst))    # [(0, 9), (1, 7), (2, 0), (3, 7)]
```

인덱스와 값을 함께 출력하려면?
```python
# 1
for i in range(len(lst)):
    print(i, lst[i])

# 2
i = 0
for v in lst:
    print(i, v)
    i += 1

# 3 : enumerate() 활용
for i, v in enumerate(lst):
    print(i, v)
```

### 8. 나눗셈 연산자 //
정수형을 나눗셈할 때 동일한 정수형을 결과로 리턴하면서 내림 연산자의 역할을 한다. (= 몫을 구한다.)
```python
5 / 3           # 1.6667
type(5 / 3)     # <class 'float'>
5 // 3          # 1
type(5 // 3)    # <class 'int'>
int(5 / 3)      # 1
type(int(5 / 3))    # <class 'int'>

# 나머지
5 % 3   # 2

# 몫과 나머지를 한 번에!
divmod(5, 3)    # (1, 2)
```

### 9. print
코딩 테스트 풀이 과정에서 디버깅을 하거나 TDD로 접근하기 어렵기에 사실상 유일한 디버깅 기능이다.

```python
# 콤마로 구분하는 경우, 한 칸 공백이 디폴트다.
print('A', 'B')     # A B

# sep 파라미터로 구분자를 공백이 아닌 다른 문자로 지정할 수 있다.
print('A', 'B', sep=',')   # A,B

# 리스트를 출력할 때는 join()으로 묶는다.
a = ['A', 'B']
print('-'.join(a))      # A-B

# f-string
print(f'{idx + 1}: {fruit}')
```

### 10. pass
수도코드로 골격을 잡고 내부 내용은 나중에 정리하고 싶을 때 사용한다.
파이썬에서 `pass`는 null 연산으로 아무것도 하지 않는 기능이다. 함수 내부를 구현하지 않아 발생하는 인덴트 오류와 같은 불필요한 오류를 방지할 수 있다. 이렇게 먼저 `mockup` 인터페이스부터 구현한 다음에, 추후 구현을 진행할 수 있게 한다.

```python
class MyClass(object):
    def method_a(self):
        pass
    
    def method_b(self):
        print("hey")

c = MyClass()
```

### 11. locals
로컬 심볼 테이블 딕셔너리를 가져오는 메소드로, 업데이트도 가능하다.
변수명을 일일이 찾아낼 필요 없이, 로컬 스코프에 정의된 모든 변수를 출력하기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회해 잘못선언한 부분을 확인하기 편하다.

```python
import pprint
pprint.pprint(locals())

# 출력 결과
# {'nums': [2, 7, 11, 15],
# 'pprint': <module 'pprint' from '/usr/lib/python3.8/pprint.py',
# 'self': <__main__.Solution object at 0x1234>,
# 'target': 9}
``` 

클래스 메소드 내부의 모든 로컬 변수를 출력해준다. 와 이건 진짜 좋다!
오늘은 책을 많이 보지 못했지만 하필 양성판정... 이비인후과 가랴 보건소 가랴 정신 없는 하루였다.
내일은 자소서 쓰면서 조금 더 봐야겠다.